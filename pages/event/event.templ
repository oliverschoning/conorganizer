package event

import (
	"database/sql"
	"fmt"
	"github.com/Regncon/conorganizer/components"
	"github.com/Regncon/conorganizer/models"
	"github.com/Regncon/conorganizer/pages/root"
	"log/slog"
	"strconv"
)

type EventMVC2 struct {
	Event      *models.Event `json:"event"`
	EditingIdx int           `json:"editingIdx"`
}

func GetEvent(db *sql.DB, id int, logger *slog.Logger) (models.Event, error) {
	query := fmt.Sprintf("SELECT id, title, short_description, game_master, system FROM events where id = 1")
	fmt.Println(query, "in query")
	rows, err := db.Query(query)
	if err != nil {
		logger.Error("Error fetching events", "err", err)
		return models.Event{}, err
	}
	defer rows.Close()

	var event models.Event
	for rows.Next() {
		var mappedEvent models.Event
		if err := rows.Scan(&mappedEvent.ID, &mappedEvent.Title, &mappedEvent.ShortDescription, &mappedEvent.GameMaster, &mappedEvent.System); err != nil {
			logger.Error("Error mapping event", "err", err)
			return models.Event{}, err
		}
		fmt.Printf("mapped event: %+v\n", event)
		event = mappedEvent
	}
	fmt.Printf("Fetched event: %+v\n", event)
	return event, nil
}

templ EventMVCView(mvc *EventMVC, db *sql.DB, logger *slog.Logger) {
	{{ event, err := GetEvent(db, mvc.EditingIdx, logger) }}
	<div id="events-container">
		if err != nil {
			<p>Error fetching events: { err.Error() }</p>
			return
		}
		<h1>{ strconv.Itoa(mvc.EditingIdx ) }</h1>
		<div
			style=" display: grid;
					grid-template-columns: repeat(auto-fit,minmax(350px, 350px));
					gap: 1rem;"
		>
			@EditRow(event, mvc.EditingIdx)
		</div>
		<code>
			<pre data-text="ctx.signals.JSON()"></pre>
		</code>
	</div>
}

templ EditRow2(event models.Event, editingIdx int) {
	if editingIdx == int(event.ID) {
		@components.EditEvent(event)
	} else {
		@root.EventCard(event)
	}
}
