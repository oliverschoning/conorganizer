package index

import (
	"database/sql"
	"github.com/Regncon/conorganizer/components"
	"github.com/Regncon/conorganizer/models"
	"github.com/Regncon/conorganizer/pages/root"
	"log/slog"
	"strconv"
)

type EventViewMode int

const (
	TodoViewModeAll EventViewMode = iota
	TodoViewModeActive
	TodoViewModeCompleted
	TodoViewModeLast
)

var TodoViewModeStrings = []string{"All", "Active", "Completed"}

type Event struct {
	Text      string `json:"text"`
	Completed bool   `json:"completed"`
}

type TodoMVC struct {
	Todos      []*Event      `json:"todos"`
	EditingIdx int           `json:"editingIdx"`
	Mode       EventViewMode `json:"mode"`
}

templ TodoMVCView(mvc *TodoMVC, db *sql.DB, logger *slog.Logger) {
	{{ events, err := root.GetEvents(db, logger) }}
	<div id="events-container">
		if err != nil {
			<p>Error fetching events: { err.Error() }</p>
			return
		}
		<h1>{ strconv.Itoa(mvc.EditingIdx ) }</h1>
		<div
			style=" display: grid;
					grid-template-columns: repeat(auto-fit,minmax(350px, 350px));
					gap: 1rem;"
		>
			for _, event := range events {
				@EditRow(event, mvc.EditingIdx)
			}
		</div>
		<code>
			<pre data-text="ctx.signals.JSON()"></pre>
		</code>
	</div>
	// 	{{
	// 		hasTodos := len(mvc.Todos) > 0
	// 		left, completed := 0, 0
	// 		for _, todo := range mvc.Todos {
	// 			if !todo.Completed {
	// 				left++
	// 			} else {
	// 				completed++
	// 			}
	// 		}
	// 		input := ""
	// 		if mvc.EditingIdx >= 0 {
	// 			input = mvc.Todos[mvc.EditingIdx].Text
	// 		}
	// 		fmt.Printf("mvc: %+v\n", mvc)
	// 	}}
	// 	<div id="events-container" class="h-full relative border border-solid border-primary rounded p-2 my-2 mx-28">
	// 		<div
	// 			class="flex flex-col w-full gap-4"
	// 			data-signals={ fmt.Sprintf("{input:'%s'}", input) }
	// 		>
	// 			<h1>TEST</h1>
	// 			<section class="flex flex-col gap-2">
	// 				<header class="flex flex-col gap-2">
	// 					<div class="alert alert-info">
	// 						@components.Icon("material-symbols:info")
	// 						<p>
	// 							<div class="text-sm">
	// 								This mini application is driven by a
	// 								<span class="italic font-bold uppercase text-primary">single get request!</span>
	// 								<br/>
	// 								As you interact with the UI, the backend state is updated and new partial HTML fragments are sent down to the client via Server-Sent Events.  You can make simple apps or full blown SPA replacements with this pattern.  Open your dev tools and watch the network tab to see the magic happen (you will want to look for the "/todos" Network/EventStream tab).
	// 							</div>
	// 						</p>
	// 					</div>
	// 					<div class="flex items-baseline gap-2 justify-center">
	// 						<h1 class="text-4xl font-bold uppercase font-brand md:text-6xl text-primary">todo's</h1>
	// 						<div class="flex items-baseline gap-2">
	// 							<h3 class="text-lg">example</h3>
	// 						</div>
	// 					</div>
	// 					<h2 class="text-center text-sm my-2">
	// 						The input is bound to a local store, but this is not a single page application.  It is like having <a class="link-primary" href="https://htmx.org" target="_blank">HTMX</a> + <a class="link-primary" href="https://alpinejs.dev/" target="_blank">Alpine.js</a> but with just one API to learn and much easier to extend.
	// 					</h2>
	// 					<div class="flex items-center gap-2">
	// 						if hasTodos {
	// 							<div class="tooltip" data-tip="toggle all todos">
	// 								<button
	// 									id="toggleAll"
	// 									class="btn btn-lg"
	// 									data-on-click="@post('/api/todos/-1/toggle')"
	// 									data-indicator="toggleAllFetching"
	// 									data-attrs-disabled="$toggleAllFetching"
	// 								>
	// 									@components.Icon("material-symbols:checklist")
	// 								</button>
	// 							</div>
	// 						}
	// 						if mvc.EditingIdx <0 {
	// 							@TodoInput(-1)
	// 						}
	// 						@components.SseIndicator("toggleAllFetching")
	// 					</div>
	// 				</header>
	// 				if hasTodos {
	// 					<section class="max-h-[calc(100vh-400px)] overflow-scroll">
	// 						<ul class="divide-y divide-primary">
	// 							for i, todo := range mvc.Todos {
	// 								@TodoRow(mvc.Mode, todo, i, i == mvc.EditingIdx)
	// 							}
	// 						</ul>
	// 					</section>
	// 					<footer class="flex flex-wrap items-center justify-between gap-2">
	// 						<span class="todo-count">
	// 							<strong>
	// 								{ fmt.Sprint(left) }
	// 								if (len(mvc.Todos) > 1) {
	// 									items
	// 								} else {
	// 									item
	// 								}
	// 							</strong> left
	// 						</span>
	// 						<div class="join">
	// 							for i := TodoViewModeAll; i < TodoViewModeLast; i++ {
	// 								if i == mvc.Mode {
	// 									<div class="btn btn-xs btn-primary join-item">{ TodoViewModeStrings[i] }</div>
	// 								} else {
	// 									<button
	// 										class="btn btn-xs join-item"
	// 										data-on-click={ fmt.Sprintf("@put('/api/todos/mode/%d')", i) }
	// 									>
	// 										{ TodoViewModeStrings[i] }
	// 									</button>
	// 								}
	// 							}
	// 						</div>
	// 						<div class="join">
	// 							if completed > 0 {
	// 								<div class="tooltip" data-tip={ fmt.Sprintf("clear %d completed todos", completed) }>
	// 									<button
	// 										class="btn btn-error btn-xs join-item"
	// 										data-on-click="@delete('/api/todos/-1')"
	// 									>
	// 										@components.Icon("material-symbols:delete")
	// 									</button>
	// 								</div>
	// 							}
	// 							<div class="tooltip" data-tip="Reset list">
	// 								<button
	// 									class="btn btn-warning btn-xs join-item"
	// 									data-on-click="@put('/api/todos/reset')"
	// 								>
	// 									@components.Icon("material-symbols:delete-sweep")
	// 								</button>
	// 							</div>
	// 						</div>
	// 					</footer>
	// 					<footer class="flex justify-center text-xs">
	// 						<div>Click to edit, click away to cancel, press enter to save.</div>
	// 					</footer>
	// 				}
	// 			</section>
	// 		</div>
	// 		<code>
	// 			<pre data-text="ctx.signals.JSON()"></pre>
	// 		</code>
	// 	</div>
}

// templ TodoInput(i int) {
// 	<input
// 		id="todoInput"
// 		data-testid="todos_input"
// 		class="flex-1 w-full italic input input-bordered input-lg"
// 		placeholder="What needs to be done?"
// 		data-bind-input
// 		data-on-keydown={ fmt.Sprintf(`
// 			if (evt.key !== 'Enter' || !$input.trim().length) return;
// 			@put('/api/todos/%d/edit');
// 			$input = '';
// 		`, i ) }
// 		if i >= 0 {
// 			data-on-click__outside="@put('/api/todos/cancel')"
// 		}
// 	/>
// }

// templ TodoRow(mode EventViewMode, todo *Event, i int, isEditing bool) {
// 	{{
// 		indicatorID := fmt.Sprintf("indicator%d", i)
// 		fetchingSignalName := fmt.Sprintf("fetching%d", i)
// 	}}
// 	if isEditing {
// 		@TodoInput(i)
// 	} else if (
// 		mode == TodoViewModeAll) ||
// 		(mode == TodoViewModeActive && !todo.Completed) ||
// 		(mode == TodoViewModeCompleted && todo.Completed) {
// 		<li class="flex items-center gap-8 p-2 group" id={ fmt.Sprintf("todo%d", i) }>
// 			<label
// 				id={ fmt.Sprintf("toggle%d", i) }
// 				class="text-4xl cursor-pointer"
// 				data-on-click={ fmt.Sprintf("@post('/api/todos/%d/toggle')", i) }
// 				data-indicator={ fetchingSignalName }
// 			>
// 				if todo.Completed {
// 					@components.Icon("material-symbols:check-box-outline")
// 				} else {
// 					@components.Icon("material-symbols:check-box-outline-blank")
// 				}
// 			</label>
// 			<label
// 				id={ indicatorID }
// 				class="flex-1 text-lg cursor-pointer select-none"
// 				data-on-click={ fmt.Sprintf("@get('/api/todos/%d/edit')", i) }
// 				data-indicator={ fetchingSignalName }
// 			>
// 				{ todo.Text }
// 			</label>
// 			@components.SseIndicator(fetchingSignalName)
// 			<button
// 				id={ fmt.Sprintf("delete%d", i) }
// 				class="invisible btn btn-error group-hover:visible"
// 				data-on-click={ fmt.Sprintf("@delete('/api/todos/%d')", i) }
// 				data-testid={ fmt.Sprintf("delete_todo%d", i) }
// 				data-indicator={ fetchingSignalName }
// 				data-attrs-disabled={ fetchingSignalName + "" }
// 			>
// 				@components.Icon("material-symbols:close")
// 			</button>
// 		</li>
// 	}
// }
templ EditRow(event models.Event, editingIdx int) {
	{{
		eventEdit := models.Event{
			ID:               event.ID,
			Title:            event.Title,
			GameMaster:       event.GameMaster,
			System:           event.System,
			ShortDescription: event.ShortDescription,
		}
	}}
	if editingIdx == int(event.ID) {
		@components.EditEvent(eventEdit)
	} else {
		@root.EventCard(event)
	}
}
